<!-- title: Public Record -->
DD01 Public Record Specification // DRAFT
================================

### Overview

The single shared history created by what we call a "public record" is a central and novel concept to Ombuds.
In the same way that a block chain can define a "public ledger" that records all account balances of digital units of currency, a block chain can define a "public record" that digitally records all public statements submitted to it.
This documents discusses the practical implications of using the Bitcoin block chain as a public ledger.

### Status of This Document

While this is not an RFC, the intention behind this document is to describe the system completely so that it is reproducible and well understood.
Please note this is a **draft of a design** that is subject to change. 
Do not rely the content of this document for any important decisions.
It has not been reviewed.

Alex, Nick -- Oct 2015

### Contents
    1. Eventual Consistenty
      1.2. Unique State
    
## Eventual Consistency
-----------------------

To ensure that nodes agree to the state of the public record, **only records that have more than six confirmations are committed to the record.**
This means that bulletins that are generated by a user and not mined are **left out of the public record.**
It also means that every full node that is constructing the record from the Bitcoin block chain has **the exact same public record**.

Full relays can inform clients of unconfirmed and recently mined record. 
A relay just cannot claim that the record is in the official public record.
By enforcing this constrait on what can go into the public record, we are able to assert that any full node is reconstructing a well-defined, globally consistent history of immutable messages.
This additionally means that to full nodes that have the same chain tip can assert that two their copies of the public record are identical.

### Best Valid Chain Constraint

The reason that the record is generated six blocks back from the chain tip is so that, with high confidence a user can assert that their message is stored permanently in that record.

### Unique State

By enforcing the depth requirements all nodes even if they have an uncertain chain tip, will have the same public record.

    A <-- B <-- C <-- D <-- E <-- F
    |     |     
   p_A   p_B    

    A <-- B <-- C <-- D <-- X <-- Y
    |     |     
   p_A   p_B    

Forcing users to wait asserts to them that their record is actually stored.

### Forking Chain Events

Drastic harm to the Bitcoin Network is done in the event of an unresolved fork.
Records that may be dropped as a result of such a chain event will be rebroadcast on a best effort basis.
This represents the one real challenge to the eventual consistence.
The other is an unknown exploit that changes either the public record or the bitcoin block chain.

### Derivation 

The block chain must remain available and effecient to rederive from some point.
A node that just joins the network can replay the blockchain and arrive at the same state as its peers.

### SQL DB

Messages are placed in a SQL db. 
That DB supports multiple message types.
Future versions might add new messages or change existing message types.

### Redudancy and Availability Requirements

Nodes that serve the public record will also serve the block chain in full.
(Possible to just serve public record without TX data, for network safeness)
    (maybe -- could split net with partially valid txs. (want oracle btc node))


Encoding Messages
-----------------

    Two formats for storing data. Others exist. 
    Future versions of node will support other formats.
    You cannot stop this from happening.

### OP_RETURN

    Messages that can go into UTXO will.

### Pay_to_PubKey

    Messages that are too big, will be sliced up and placed in P2PKH txs.
    This grows the UTXO
    Redudancy advantage
    DUST payments


Excluded Messages
-----------------

    Miners can elect to not mine messages.
    Nodes will not drop messages in the system that are bulletins.
    They will be placed in a seperate DB... the ignored_set.

### Orphaned Messages

    Mined, but then mined around.

### Ignored Messages
    
    Never mined, dropped from mempools.


Versioning
----------

V1<--V2<--V3<-- Latest version supports old message formats.

Agreement of DB breaks off when new version adds fields that old nodes do not see, when this occurs their databases diverge.
