<!-- title: Public Record -->
DD01 Public Record Specification // DRAFT
================================

Overview
--------

The single shared history created by what we call a "public record" is a central and novel concept to Ombuds.
In the same way that a block chain can define a "public ledger" that records all account balances of digital units of currency, a block chain can define a "public record" that digitally records all public statements submitted to it.
This documents discusses the practical implications of using the Bitcoin block chain as a public ledger.

Status of This Document
-----------------------

While this is not an RFC, the intention behind this document is to describe the system completely so that it is reproducible and well understood.
Please note this is a **draft of a design** that is subject to change. 
Do not rely the content of this document for critical decisions.
It has not been reviewed.

Alex, Nick -- Oct 2015

Contents
--------
    1. Eventual Consistenty
      1.2. Unique State
    
Eventual Consistency
--------------------

To ensure that nodes agree to the state of the public record, only records that have more than **three** confirmations are marked as committed to the record.
This means that bulletins that are generated by a user and not mined are left out of the public record.
This also means that every full node that is constructing the record from the Bitcoin block chain that is consistent to **three** blocks deep has the exact same public record.

Nodes in the network can still inform clients of unconfirmed and recently mined records. 
A relay just cannot claim that a specific record is in the official public record, if it is not three blocks deep in the chain.
By enforcing this constrait on the public record, we are able to assert that any full node is reconstructing a well-defined, globally consistent history of immutable messages that takes the equivalent of three blocks of work to undo.

Choice of Parameters
--------------------

After a record is three blocks deep we call it "confirmed."
Records that are in the best chain, but not three blocks deep are called "pending" or "pending confirmation."
The reason that the record is generated from records **three** blocks deep is so that, a user is not told that their message is confirmed or "in the chain" until a significant amount of work has been invested in those messages.

There is a tradeoff between speed of confirmation and security that comes from waiting for more blocks in the chain before considering a bitcoin transaction "confirmed".
For our purposes we have planted our flag in the ground at three blocks, and acknowledge the dangers in doing so. 

However, this is a tunable parameter and it is subject to change.

Database Structure
------------------

The database is broken into two crucial components.

    -------------
    | Floating  |
    -------------

    -------------
    |  Pending  |
    |  Commit   |
    -------------



Unique State
------------

By enforcing the depth requirements all nodes -- even if they different chain tips -- will have the same public record.

    A <-- B <-- D <-- E
    |     |     
   p_A   p_B    

    A <-- B <-- X <-- Y
    |     |     
   p_A   p_B    

Forcing users to wait before they are told their message is commit, while not ideal is better than the alternative.

### Longer Reorganizations

In the event
Records that may be dropped as a result of such a chain event will be rebroadcast on a best effort basis.
This represents the one real challenge to the eventual consistence.
The other is an unknown exploit that changes either the public record or the bitcoin block chain.

### Derivation 

The block chain must remain available and effecient to rederive from some point.
A node that just joins the network can replay the blockchain and arrive at the same state as its peers.

### Redudancy and Availability Requirements

Nodes that serve the public record will also serve the block chain in full.
(Possible to just serve public record without TX data, for network safeness)
    (maybe -- could split net with partially valid txs. (want oracle btc node))


Encoded Message Formats
-----------------------

Two formats for storing data. Others exist. 
Future versions of node will support other formats.
You cannot stop this from happening.

### OP_RETURN

Messages that can fit into OP_RETURNs will.

### Pay_to_PubKey

Messages that are too big, will be sliced up and placed in P2PKH txs.
This grows the UTXO.
Redudancy advantage.
DUST payments.


Excluded Messages
-----------------

    Miners can elect to exclude messages, but not mining specific bulletins.
    Nodes will not drop messages in the system that are bulletins.

### Orphaned Messages

    Mined, but then mined around.

### Ignored Messages
    
    Never mined, dropped from mempools.


Versioning
----------

V1<--V2<--V3<-- Latest version supports old message formats.

Agreement of DB breaks off when new version adds fields that old nodes do not see, when this occurs their databases diverge.
